{
  "name": "Bible AI Chatbot - Web API (com Base SQL)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat/bible",
        "responseMode": "responseNode",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-trigger",
      "name": "Webhook - Chat Bible API",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [250, 300],
      "webhookId": "bible-chat-webhook",
      "notes": "Endpoint principal: POST /webhook/chat/bible\n\nEspera body JSON:\n{\n  \"message\": \"pergunta do usuario\",\n  \"sessionId\": \"id-unico-sessao\",\n  \"userId\": \"id-usuario-opcional\"\n}"
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// VALIDACAO DE PARAMETROS DA REQUISICAO\n// ========================================\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const body = item.json.body || item.json;\n  \n  // Validar campo obrigatorio: message\n  if (!body.message || typeof body.message !== 'string' || body.message.trim() === '') {\n    throw new Error('VALIDATION_ERROR: Campo \"message\" e obrigatorio e deve ser uma string nao vazia.');\n  }\n  \n  // Gerar sessionId se nao fornecido\n  const sessionId = body.sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  \n  // UserId opcional\n  const userId = body.userId || 'anonymous';\n  \n  // Limitar tamanho da mensagem (seguranca)\n  const maxLength = 2000;\n  const userMessage = body.message.trim().substring(0, maxLength);\n  \n  results.push({\n    json: {\n      userMessage,\n      sessionId,\n      userId,\n      timestamp: new Date().toISOString(),\n      requestId: `req_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "validate-params",
      "name": "Validar Parametros",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [470, 300],
      "notes": "Valida os parametros recebidos:\n- message (obrigatorio)\n- sessionId (gerado se nao fornecido)\n- userId (opcional, default: anonymous)\n\nLimita mensagem a 2000 caracteres por seguranca."
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// EXTRAIR TERMOS DE BUSCA DA PERGUNTA\n// ========================================\n\nconst items = $input.all();\nconst results = [];\n\n// Palavras comuns a ignorar na busca\nconst stopWords = new Set([\n  'o', 'a', 'os', 'as', 'um', 'uma', 'uns', 'umas',\n  'de', 'da', 'do', 'das', 'dos', 'em', 'na', 'no', 'nas', 'nos',\n  'por', 'para', 'com', 'sem', 'sob', 'sobre',\n  'e', 'ou', 'mas', 'porem', 'contudo', 'entretanto',\n  'que', 'qual', 'quais', 'quem', 'onde', 'quando', 'como', 'porque',\n  'esse', 'essa', 'esses', 'essas', 'este', 'esta', 'estes', 'estas',\n  'isso', 'isto', 'aquilo', 'aquele', 'aquela',\n  'meu', 'minha', 'seu', 'sua', 'nosso', 'nossa',\n  'ser', 'estar', 'ter', 'haver', 'fazer', 'ir', 'vir',\n  'foi', 'era', 'seria', 'sido', 'sendo',\n  'me', 'te', 'se', 'nos', 'vos', 'lhe', 'lhes',\n  'muito', 'pouco', 'mais', 'menos', 'bem', 'mal',\n  'sim', 'nao', 'talvez', 'ja', 'ainda', 'sempre', 'nunca',\n  'aqui', 'ali', 'la', 'ca', 'onde',\n  'biblia', 'versiculo', 'capitulo', 'livro', 'texto', 'diz', 'fala', 'disse'\n]);\n\nfor (const item of items) {\n  const { userMessage, sessionId, userId, timestamp, requestId } = item.json;\n  \n  // Extrair termos relevantes da pergunta\n  const words = userMessage\n    .toLowerCase()\n    .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') // Remove acentos para busca\n    .replace(/[^a-z0-9\\s]/g, ' ') // Remove pontuacao\n    .split(/\\s+/)\n    .filter(word => word.length > 2 && !stopWords.has(word));\n  \n  // Detectar referencias biblicas (ex: Joao 3:16, Genesis 1)\n  const refPattern = /([1-3]?\\s*[a-zA-Z]+)\\s*(\\d+)(?:[:.,](\\d+))?(?:\\s*[-a]\\s*(\\d+))?/gi;\n  const references = [];\n  let match;\n  while ((match = refPattern.exec(userMessage)) !== null) {\n    references.push({\n      livro: match[1].trim(),\n      capitulo: parseInt(match[2]),\n      versiculoInicio: match[3] ? parseInt(match[3]) : null,\n      versiculoFim: match[4] ? parseInt(match[4]) : null\n    });\n  }\n  \n  // Construir termos de busca (maximo 5 termos mais relevantes)\n  const searchTerms = [...new Set(words)].slice(0, 5).join(' ');\n  \n  results.push({\n    json: {\n      userMessage,\n      sessionId,\n      userId,\n      timestamp,\n      requestId,\n      searchTerms,\n      references,\n      hasReferences: references.length > 0\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "extract-search-terms",
      "name": "Extrair Termos de Busca",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [690, 300],
      "notes": "Analisa a pergunta do usuario para:\n1. Extrair palavras-chave relevantes\n2. Detectar referencias biblicas (ex: Joao 3:16)\n3. Preparar termos para busca no banco"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Buscar versiculos relevantes para o contexto\n-- Combina busca full-text e por referencia\n\nWITH busca_texto AS (\n    SELECT\n        l.liv_nome as livro,\n        v.ver_capitulo as capitulo,\n        v.ver_versiculo as versiculo,\n        v.ver_texto as texto,\n        l.liv_nome || ' ' || v.ver_capitulo || ':' || v.ver_versiculo as referencia,\n        ts_rank(to_tsvector('portuguese', v.ver_texto), plainto_tsquery('portuguese', $1)) as relevancia\n    FROM versiculos v\n    JOIN livros l ON v.ver_liv_id = l.liv_id\n    WHERE \n        $1 != '' AND\n        to_tsvector('portuguese', v.ver_texto) @@ plainto_tsquery('portuguese', $1)\n    ORDER BY relevancia DESC\n    LIMIT 10\n)\nSELECT * FROM busca_texto\nWHERE relevancia > 0.01\nORDER BY relevancia DESC\nLIMIT 8;",
        "options": {
          "queryParams": "={{ [$json.searchTerms || ''] }}"
        }
      },
      "id": "search-bible-db",
      "name": "Buscar na Biblia (PostgreSQL)",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [910, 240],
      "credentials": {
        "postgres": {
          "id": "CONFIGURE_POSTGRES_CREDENTIAL",
          "name": "PostgreSQL Bible DB"
        }
      },
      "notes": "Busca versiculos relevantes usando full-text search do PostgreSQL.\n\nCONFIGURACAO NECESSARIA:\n1. Criar credencial PostgreSQL no n8n\n2. Host: postgres (nome do container)\n3. Database: n8n\n4. User/Password: conforme .env"
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "-- Buscar versiculos por referencia especifica\nSELECT\n    l.liv_nome as livro,\n    v.ver_capitulo as capitulo,\n    v.ver_versiculo as versiculo,\n    v.ver_texto as texto,\n    l.liv_nome || ' ' || v.ver_capitulo || ':' || v.ver_versiculo as referencia\nFROM versiculos v\nJOIN livros l ON v.ver_liv_id = l.liv_id\nWHERE \n    LOWER(l.liv_nome) LIKE LOWER($1 || '%')\n    AND v.ver_capitulo = $2\n    AND ($3::int IS NULL OR v.ver_versiculo >= $3)\n    AND ($4::int IS NULL OR v.ver_versiculo <= COALESCE($4, $3, v.ver_versiculo))\nORDER BY v.ver_versiculo\nLIMIT 15;",
        "options": {
          "queryParams": "={{ $json.hasReferences && $json.references[0] ? [$json.references[0].livro, $json.references[0].capitulo, $json.references[0].versiculoInicio, $json.references[0].versiculoFim] : ['', 0, null, null] }}"
        }
      },
      "id": "search-by-reference",
      "name": "Buscar por Referencia",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [910, 400],
      "credentials": {
        "postgres": {
          "id": "CONFIGURE_POSTGRES_CREDENTIAL",
          "name": "PostgreSQL Bible DB"
        }
      },
      "notes": "Busca versiculos quando o usuario menciona uma referencia especifica como 'Joao 3:16' ou 'Genesis 1:1-10'"
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// COMBINAR RESULTADOS E CONSTRUIR CONTEXTO\n// ========================================\n\n// Pegar dados da validacao\nconst inputData = $('Extrair Termos de Busca').first().json;\n\n// Pegar resultados das buscas\nconst textSearchResults = $('Buscar na Biblia (PostgreSQL)').all().map(i => i.json);\nconst refSearchResults = $('Buscar por Referencia').all().map(i => i.json);\n\n// Combinar resultados, priorizando referencias especificas\nconst allResults = [];\nconst seenRefs = new Set();\n\n// Primeiro adiciona resultados de referencia especifica\nfor (const result of refSearchResults) {\n  if (result.referencia && !seenRefs.has(result.referencia)) {\n    seenRefs.add(result.referencia);\n    allResults.push(result);\n  }\n}\n\n// Depois adiciona resultados da busca por texto\nfor (const result of textSearchResults) {\n  if (result.referencia && !seenRefs.has(result.referencia)) {\n    seenRefs.add(result.referencia);\n    allResults.push(result);\n  }\n}\n\n// Limitar a 10 versiculos para o contexto\nconst contextVerses = allResults.slice(0, 10);\n\n// Construir contexto biblico formatado\nlet bibleContext = '';\nif (contextVerses.length > 0) {\n  bibleContext = '\\n\\n## VERSICULOS RELEVANTES DA BIBLIA (use como referencia):\\n';\n  for (const verse of contextVerses) {\n    bibleContext += `\\n**${verse.referencia}**: \"${verse.texto}\"\\n`;\n  }\n  bibleContext += '\\n---\\n';\n}\n\nreturn [{\n  json: {\n    ...inputData,\n    bibleContext,\n    versesFound: contextVerses.length,\n    contextVerses\n  }\n}];"
      },
      "id": "combine-results",
      "name": "Combinar Resultados",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1130, 300],
      "notes": "Combina resultados das duas buscas:\n1. Busca por referencia especifica\n2. Busca full-text por palavras-chave\n\nRemove duplicatas e limita a 10 versiculos para o contexto."
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// CONSTRUCAO DO PROMPT COM CONTEXTO BIBLICO\n// ========================================\n\nconst items = $input.all();\nconst results = [];\n\n// Prompt de sistema com contexto biblico profundo\nconst BIBLE_SYSTEM_PROMPT = `Voce e um assistente espiritual cristao especializado na Biblia Sagrada. Seu papel e:\n\n## IDENTIDADE E PROPOSITO\n- Voce e um conselheiro biblico sabio, compassivo e acolhedor\n- Seu conhecimento abrange toda a Biblia (Antigo e Novo Testamento)\n- Voce conhece profundamente teologia crista, historia biblica e interpretacao das Escrituras\n- IMPORTANTE: Voce tem acesso a uma base de dados com todos os versiculos da Biblia em portugues\n\n## DIRETRIZES DE RESPOSTA\n1. **Base Biblica**: Sempre fundamente suas respostas nas Escrituras Sagradas\n2. **Citacoes**: Use os versiculos fornecidos no contexto e cite com referencia completa (ex: Joao 3:16)\n3. **Contextualizacao**: Explique o contexto historico e cultural quando relevante\n4. **Aplicacao Pratica**: Conecte os ensinamentos biblicos com a vida cotidiana\n5. **Tom Acolhedor**: Seja gentil, empatico e encorajador\n6. **Precisao**: Se nao souber algo com certeza, admita humildemente\n\n## USANDO OS VERSICULOS DO CONTEXTO\n- Quando versiculos relevantes forem fornecidos, USE-OS na sua resposta\n- Cite o texto exato entre aspas seguido da referencia\n- Se o usuario perguntar por uma referencia especifica, cite o versiculo completo\n- Relacione os versiculos com a pergunta do usuario\n\n## LIMITACOES\n- Nao faca previsoes sobre o futuro ou profecias pessoais\n- Nao substitua aconselhamento profissional (medico, juridico, psicologico)\n- Nao entre em debates denominacionais divisivos\n- Mantenha respeito por diferentes tradicoes cristas\n\n## FORMATO DE RESPOSTA\n- Seja conciso mas completo\n- Use linguagem clara e acessivel\n- Organize respostas longas em topicos quando apropriado\n- Sempre termine com uma palavra de encorajamento ou reflexao\n\nResponda em portugues brasileiro de forma natural e acolhedora.`;\n\nfor (const item of items) {\n  const { userMessage, sessionId, userId, timestamp, requestId, bibleContext, versesFound } = item.json;\n  \n  // Construir mensagem do usuario com contexto biblico\n  let enhancedUserMessage = userMessage;\n  if (bibleContext && versesFound > 0) {\n    enhancedUserMessage = userMessage + bibleContext;\n  }\n  \n  // Construir mensagens para a API\n  const messages = [\n    {\n      role: 'system',\n      content: BIBLE_SYSTEM_PROMPT\n    },\n    {\n      role: 'user',\n      content: enhancedUserMessage\n    }\n  ];\n  \n  results.push({\n    json: {\n      messages,\n      userMessage,\n      sessionId,\n      userId,\n      timestamp,\n      requestId,\n      versesFound,\n      model: 'gpt-4o-mini', // Pode ser alterado para gpt-4, claude, etc.\n      maxTokens: 1500,\n      temperature: 0.7\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "build-prompt",
      "name": "Construir Prompt Biblico",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1350, 300],
      "notes": "Monta o prompt com contexto biblico e versiculos do banco.\n\nO system prompt define:\n- Identidade do assistente\n- Diretrizes de resposta\n- Instrucoes para usar os versiculos\n- Limitacoes eticas\n- Formato de saida\n\nVariaveis configuraveis:\n- model: modelo de IA\n- maxTokens: limite de tokens\n- temperature: criatividade"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ {\n  \"model\": $json.model,\n  \"messages\": $json.messages,\n  \"max_tokens\": $json.maxTokens,\n  \"temperature\": $json.temperature,\n  \"presence_penalty\": 0.1,\n  \"frequency_penalty\": 0.1\n} }}",
        "options": {
          "timeout": 60000,
          "response": {
            "response": {
              "fullResponse": true
            }
          }
        }
      },
      "id": "call-openai",
      "name": "Chamar OpenAI API",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1570, 300],
      "credentials": {
        "httpHeaderAuth": {
          "id": "CONFIGURE_CREDENTIAL_ID",
          "name": "OpenAI API Key"
        }
      },
      "notes": "Chamada para OpenAI Chat Completions API.\n\nCONFIGURACAO NECESSARIA:\n1. Criar credencial HTTP Header Auth no n8n\n2. Header Name: Authorization\n3. Header Value: Bearer sk-YOUR-API-KEY\n\nTimeout: 60 segundos"
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// PROCESSAR RESPOSTA DA IA\n// ========================================\n\nconst items = $input.all();\nconst inputData = $('Construir Prompt Biblico').first().json;\nconst results = [];\n\nfor (const item of items) {\n  const response = item.json;\n  \n  // Verificar se a resposta e valida\n  if (!response.body || !response.body.choices || !response.body.choices[0]) {\n    throw new Error('AI_ERROR: Resposta invalida da API de IA');\n  }\n  \n  const aiResponse = response.body.choices[0].message.content;\n  const usage = response.body.usage || {};\n  \n  results.push({\n    json: {\n      response: aiResponse,\n      status: 'success',\n      metadata: {\n        requestId: inputData.requestId,\n        sessionId: inputData.sessionId,\n        userId: inputData.userId,\n        timestamp: inputData.timestamp,\n        responseTimestamp: new Date().toISOString(),\n        model: response.body.model || inputData.model,\n        versesUsed: inputData.versesFound || 0,\n        tokensUsed: {\n          prompt: usage.prompt_tokens || 0,\n          completion: usage.completion_tokens || 0,\n          total: usage.total_tokens || 0\n        }\n      }\n    }\n  });\n}\n\nreturn results;"
      },
      "id": "process-response",
      "name": "Processar Resposta IA",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1790, 300],
      "notes": "Extrai e formata a resposta da IA.\n\nRetorna objeto com:\n- response: texto da resposta\n- status: success/error\n- metadata: informacoes da requisicao incluindo versiculos usados"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}",
        "options": {
          "responseCode": 200,
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              },
              {
                "name": "X-Request-Id",
                "value": "={{ $json.metadata.requestId }}"
              }
            ]
          }
        }
      },
      "id": "respond-success",
      "name": "Responder Sucesso",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2010, 300],
      "notes": "Retorna resposta JSON de sucesso (HTTP 200).\n\nFormato:\n{\n  \"response\": \"texto da IA\",\n  \"status\": \"success\",\n  \"metadata\": {...}\n}"
    },
    {
      "parameters": {
        "jsCode": "// ========================================\n// TRATAMENTO DE ERROS CENTRALIZADO\n// ========================================\n\nconst error = $input.first().json;\nconst errorMessage = error.message || error.error?.message || 'Erro desconhecido';\nconst errorStack = error.stack || '';\n\n// Classificar tipo de erro\nlet errorType = 'INTERNAL_ERROR';\nlet statusCode = 500;\nlet userMessage = 'Ocorreu um erro interno. Por favor, tente novamente.';\n\nif (errorMessage.includes('VALIDATION_ERROR')) {\n  errorType = 'VALIDATION_ERROR';\n  statusCode = 400;\n  userMessage = errorMessage.replace('VALIDATION_ERROR: ', '');\n} else if (errorMessage.includes('AI_ERROR')) {\n  errorType = 'AI_SERVICE_ERROR';\n  statusCode = 502;\n  userMessage = 'O servico de IA esta temporariamente indisponivel. Tente novamente em alguns instantes.';\n} else if (errorMessage.includes('timeout') || errorMessage.includes('ETIMEDOUT')) {\n  errorType = 'TIMEOUT_ERROR';\n  statusCode = 504;\n  userMessage = 'A requisicao demorou muito para ser processada. Tente novamente.';\n} else if (errorMessage.includes('401') || errorMessage.includes('Unauthorized')) {\n  errorType = 'AUTH_ERROR';\n  statusCode = 500;\n  userMessage = 'Erro de configuracao do servico. Contate o administrador.';\n} else if (errorMessage.includes('429') || errorMessage.includes('rate limit')) {\n  errorType = 'RATE_LIMIT_ERROR';\n  statusCode = 429;\n  userMessage = 'Muitas requisicoes. Aguarde alguns segundos e tente novamente.';\n} else if (errorMessage.includes('relation') || errorMessage.includes('does not exist')) {\n  errorType = 'DATABASE_ERROR';\n  statusCode = 500;\n  userMessage = 'Base de dados da Biblia nao encontrada. Execute o script de importacao.';\n}\n\nreturn [{\n  json: {\n    response: null,\n    status: 'error',\n    error: {\n      type: errorType,\n      message: userMessage,\n      code: statusCode,\n      timestamp: new Date().toISOString(),\n      _debug: {\n        originalMessage: errorMessage,\n        stack: errorStack.substring(0, 500)\n      }\n    }\n  },\n  statusCode\n}];"
      },
      "id": "error-handler",
      "name": "Tratar Erros",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1350, 520],
      "notes": "Tratamento centralizado de erros.\n\nClassifica erros por tipo:\n- VALIDATION_ERROR (400)\n- AI_SERVICE_ERROR (502)\n- TIMEOUT_ERROR (504)\n- AUTH_ERROR (500)\n- RATE_LIMIT_ERROR (429)\n- DATABASE_ERROR (500)\n- INTERNAL_ERROR (500)"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { response: $json.response, status: $json.status, error: $json.error } }}",
        "options": {
          "responseCode": "={{ $json.statusCode }}",
          "responseHeaders": {
            "entries": [
              {
                "name": "Content-Type",
                "value": "application/json"
              }
            ]
          }
        }
      },
      "id": "respond-error",
      "name": "Responder Erro",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1570, 520],
      "notes": "Retorna resposta de erro com codigo HTTP apropriado."
    },
    {
      "parameters": {
        "content": "## Bible AI Chatbot - Com Base SQL\n\n### Endpoint\n`POST /webhook/chat/bible`\n\n### Body (JSON)\n```json\n{\n  \"message\": \"O que diz Joao 3:16?\",\n  \"sessionId\": \"opcional\",\n  \"userId\": \"opcional\"\n}\n```\n\n### NOVO: Busca na Base SQL\nO chatbot agora busca versiculos relevantes no PostgreSQL antes de responder:\n\n1. **Busca por texto**: encontra versiculos com palavras-chave\n2. **Busca por referencia**: encontra versiculos especificos (ex: Joao 3:16)\n\n### Configuracao PostgreSQL\n1. Criar credencial PostgreSQL no n8n\n   - Host: `postgres`\n   - Port: `5432`\n   - Database: `n8n`\n   - User: `n8n`\n   - Password: (conforme .env)\n\n2. Executar script de importacao:\n   ```\n   python scripts/import_biblia.py\n   ```",
        "height": 520,
        "width": 360,
        "color": 4
      },
      "id": "sticky-docs",
      "name": "Documentacao",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [-80, 140]
    },
    {
      "parameters": {
        "content": "## Fluxo de Execucao\n\n1. **Webhook** recebe POST\n2. **Validacao** dos parametros\n3. **Extrai termos** de busca\n4. **Busca paralela** no PostgreSQL:\n   - Por texto (full-text)\n   - Por referencia biblica\n5. **Combina resultados**\n6. **Prompt** com contexto biblico\n7. **OpenAI** processa\n8. **Resposta** formatada",
        "height": 280,
        "width": 260,
        "color": 6
      },
      "id": "sticky-flow",
      "name": "Fluxo",
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [310, 60]
    }
  ],
  "connections": {
    "Webhook - Chat Bible API": {
      "main": [
        [
          {
            "node": "Validar Parametros",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validar Parametros": {
      "main": [
        [
          {
            "node": "Extrair Termos de Busca",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extrair Termos de Busca": {
      "main": [
        [
          {
            "node": "Buscar na Biblia (PostgreSQL)",
            "type": "main",
            "index": 0
          },
          {
            "node": "Buscar por Referencia",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar na Biblia (PostgreSQL)": {
      "main": [
        [
          {
            "node": "Combinar Resultados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Buscar por Referencia": {
      "main": [
        [
          {
            "node": "Combinar Resultados",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Combinar Resultados": {
      "main": [
        [
          {
            "node": "Construir Prompt Biblico",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Construir Prompt Biblico": {
      "main": [
        [
          {
            "node": "Chamar OpenAI API",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Chamar OpenAI API": {
      "main": [
        [
          {
            "node": "Processar Resposta IA",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Processar Resposta IA": {
      "main": [
        [
          {
            "node": "Responder Sucesso",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tratar Erros": {
      "main": [
        [
          {
            "node": "Responder Erro",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [
    {
      "name": "chatbot",
      "id": "1"
    },
    {
      "name": "bible",
      "id": "2"
    },
    {
      "name": "ai",
      "id": "3"
    },
    {
      "name": "postgresql",
      "id": "5"
    }
  ],
  "triggerCount": 1,
  "meta": {
    "templateId": "bible-ai-chatbot-sql",
    "templateCredsSetupCompleted": false,
    "instanceId": "easypanel-n8n"
  },
  "pinData": {}
}
